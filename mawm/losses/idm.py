"""Contain various loss functions used for optimization."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/03e_losses.idm.ipynb.

# %% auto 0
__all__ = ['CONV_LAYERS_CONFIG', 'IDMLoss']

# %% ../../nbs/03e_losses.idm.ipynb 3
from fastcore import *
from fastcore.utils import *

# %% ../../nbs/03e_losses.idm.ipynb 4
import torch
import torch.nn as nn
import torch.nn.functional as F

# %% ../../nbs/03e_losses.idm.ipynb 5
from ..models.utils import *
from ..models.misc import MLP
from functools import reduce
import operator



# %% ../../nbs/03e_losses.idm.ipynb 6
CONV_LAYERS_CONFIG = {
    "a": [
        (-1, 32, 3, 1, 1),
        ("max_pool", 2, 2, 0),
        (32, 32, 3, 1, 1),
        ("max_pool", 2, 2, 0),
        (32, 32, 3, 1, 1),
        ("fc", -1, 5),
    ],
    "b": [
        (-1, 32, 3, 1, 1),
        ("max_pool", 2, 2, 0),
        (32, 32, 3, 1, 1),
        ("max_pool", 2, 2, 0),
        ("fc", -1, 2),
    ],
}

# %% ../../nbs/03e_losses.idm.ipynb 7
from einops import rearrange, repeat, einsum
class IDMLoss(torch.nn.Module):
    """Inverse Dynamics Model (IDM) objective.
    Trains an action predictor to predict the next action given the current
    state and the next state."""

    def __init__(
        self, config, repr_dim, device= "cuda"
    ):
        super().__init__()
        self.config = config

        if config.arch == "conv":
            input_dim = (repr_dim[0] * 2, *repr_dim[1:])
            self.action_predictor = build_conv(
                CONV_LAYERS_CONFIG[config.arch_subclass], input_dim=input_dim
            ).to(device)
        else:
            if isinstance(repr_dim, tuple):
                repr_dim = reduce(operator.mul, repr_dim)
            self.action_predictor = MLP(
                arch=config.arch,
                input_dim=repr_dim * 2,
                output_shape=config.action_dim,
            ).to(device)


# %% ../../nbs/03e_losses.idm.ipynb 8
@patch
def __call__(self: IDMLoss, embeddings, predictions, actions):
    actions = rearrange(actions, "b t ... -> t b ...")
    actions = actions[:-1].flatten(start_dim=0, end_dim=1)

    if self.config.use_pred:
        curr_embeds = predictions[:-1]
        next_embeds = embeddings[1:]
    else:
        curr_embeds = embeddings[:-1]
        next_embeds = embeddings[1:]

    if self.config.arch == "conv":
        repr_input = torch.cat([curr_embeds, next_embeds], dim=2)
    else:
        curr_embeds = flatten_conv_output(curr_embeds)
        next_embeds = flatten_conv_output(next_embeds)
        repr_input = torch.cat([curr_embeds, next_embeds], dim=-1)
    
    repr_input = rearrange(repr_input, "t b ... -> (t b) ...")
    actions_pred = self.action_predictor(repr_input)

    action_loss = F.cross_entropy(
        actions_pred,
        actions.to(actions_pred.device),
        reduction="mean",
    )
    
    # total_loss = action_loss
    return action_loss
