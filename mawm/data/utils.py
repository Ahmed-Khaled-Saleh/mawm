"""This module handles all communication-related functionalities, including message passing, event handling, and notifications."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/01b_data.utils.ipynb.

# %% auto 0
__all__ = ['base_tf', 'denormalize_tf', 'lejepa_train_tf', 'lejepa_test_tf', 'msg_tf', 'get_graphics_primitives', 'show_grid',
           'get_cell_color', 'get_grid_chars', 'generate_msg', 'MsgTransform', 'debug_channels', 'plot_grid',
           'init_data', 'show_batch']

# %% ../../nbs/01b_data.utils.ipynb 3
from fastcore import *
from fastcore.utils import *

# %% ../../nbs/01b_data.utils.ipynb 5
import torch
from torchvision.transforms import v2
base_tf = v2.Compose([
    v2.ToPILImage(),
    v2.ToImage(),
    v2.ToDtype(torch.float32, scale=True),
    v2.Normalize(mean=[0.5, 0.5, 0.5], std=[0.5, 0.5, 0.5]),
])

denormalize_tf = v2.Compose([
    v2.Normalize(mean=[0., 0., 0.], std=[1/0.5, 1/0.5, 1/0.5]),
    v2.Normalize(mean=[-0.5, -0.5, -0.5], std=[1., 1., 1.]),
])

# %% ../../nbs/01b_data.utils.ipynb 6
import torch
from torchvision.transforms import v2
lejepa_train_tf = v2.Compose(
    [
        v2.ToPILImage(),
        v2.RandomResizedCrop(42, scale=(0.8, 1.0)), 
        v2.RandomApply([v2.ColorJitter(0.4, 0.4, 0.4, 0.1)], p=0.8),
        v2.RandomGrayscale(p=0.2),
        v2.RandomApply([v2.GaussianBlur(kernel_size=3, sigma=(0.1, 2.0))], p=0.1),
        v2.RandomHorizontalFlip(),
        v2.ToImage(),
        v2.ToDtype(torch.float32, scale=True),
        v2.Normalize(mean=[0.5, 0.5, 0.5], std=[0.5, 0.5, 0.5]),
    ]
)


lejepa_test_tf = v2.Compose(
            [
                v2.ToPILImage(),
                v2.Resize(42),
                v2.CenterCrop(42),
                v2.ToImage(),
                v2.ToDtype(torch.float32, scale=True),
                v2.Normalize(mean=[0.5, 0.5, 0.5], std=[0.5, 0.5, 0.5]),
            ]
        )

# %% ../../nbs/01b_data.utils.ipynb 9
import cv2
import numpy as np
import torch
def get_graphics_primitives(img_np):
    img = cv2.cvtColor(img_np, cv2.COLOR_RGB2BGR)
    pixels = img.reshape(-1, 3)
    colors = np.unique(pixels, axis=0)

    primitives = []
    background_color = np.array([0, 0, 0])  # assuming black background
    for color in colors:
        if np.all(color == background_color):
            continue

        mask = cv2.inRange(img, color, color)
        contours, _ = cv2.findContours(
            mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE
        )

        for cnt in contours:
            x, y, w, h = cv2.boundingRect(cnt)
            primitives.append((color, x, y, w, h))
            
    return primitives

# %% ../../nbs/01b_data.utils.ipynb 11
import cv2
import matplotlib.pyplot as plt
def show_grid(img, GRID = 7, CELL = 6):
    if not CELL:
        CELL = img.shape[0] // GRID
    
    vis = img.copy()
    vis = cv2.cvtColor(vis, cv2.COLOR_BGR2RGB)
    for i in range(1, GRID):
        cv2.line(vis, (i*CELL, 0), (i*CELL, 42), (255,255,255), 1)
        cv2.line(vis, (0, i*CELL), (42, i*CELL), (255,255,255), 1)
    plt.imshow(vis, interpolation="nearest")
    plt.axis("off")

    return vis


# %% ../../nbs/01b_data.utils.ipynb 13
def get_cell_color(cell):
    np_to_tuple = lambda arr: tuple(int(x) for x in arr)
    pixels = cell.reshape(-1, 3)
    colors, counts = np.unique(pixels, axis=0, return_counts=True)
    
    if len(colors) == 1:
        if np_to_tuple(colors[0]) in [(0, 255, 0)]:
            return "G" #"Goal"
        elif np_to_tuple(colors[0]) in [(74, 65, 42)]:
            return "W" #"Wall"
        else:
            return "E" #"Empty"
        
    else:
        
        for color in colors:
            if np_to_tuple(color) in [(198, 0, 0), (28, 0, 0), (255, 0, 0)]:
                color = (255, 0, 0)
                return "R" #"RedAgent"
            elif np_to_tuple(color) in [(0, 0, 198), (0, 0, 255)]:
                color = (0, 0, 255)
                return "B" #"BlueAgent"
                
    

# %% ../../nbs/01b_data.utils.ipynb 14
def get_grid_chars(img, GRID=7, CELL=6): #cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    cells = [[img[j*CELL:(j+1)*CELL, i*CELL:(i+1)*CELL]
              for i in range(GRID)]
              for j in range(GRID)
            ]
    
    grid = np.zeros((GRID,GRID), dtype=object)
    for r in range(GRID):
        for c in range(GRID):
            color = get_cell_color(cells[r][c])
            grid[r][c] = color
    return grid

# %% ../../nbs/01b_data.utils.ipynb 15
import torch.nn.functional as F
import torch
from einops import rearrange
def generate_msg(inp):
    img, agent_id, done = inp
    if not done:
        grid = get_grid_chars(img)
    else:
        grid = np.array([['G' for _ in range(7)] for _ in range(7)])

    grid[3,3] = 'R' if '0' in agent_id else 'B' # Agent's own position

    mapping = {'E': 0, 'W': 1, 'G': 2, 'R': 3, 'B': 4}
    int_grid = np.array([[mapping[char] for char in row] for row in grid])
    
    one_hot_msg = F.one_hot(torch.from_numpy(int_grid).long(), num_classes=5) # [7,7,5]
    one_hot_msg = rearrange(one_hot_msg, 'h w c -> c h w') # [5,7,7]
    
    return one_hot_msg.to(torch.float32)


# %% ../../nbs/01b_data.utils.ipynb 16
class MsgTransform(torch.nn.Module):
    def __init__(self, func=generate_msg):
        super().__init__()
        self.func = func
        
    def forward(self, inp):
        return self.func(inp)
    
from torchvision.transforms import v2
msg_tf = v2.Compose([
    MsgTransform()
])

# %% ../../nbs/01b_data.utils.ipynb 21
def debug_channels(msg):
    fig, axes = plt.subplots(1, 5, figsize=(15, 3))
    titles = ['Empty', 'Wall', 'Goal', 'Red Agent', 'Blue Agent']

    for i in range(5):
        axes[i].imshow(msg[:, :, i].numpy(), cmap='gray')
        axes[i].set_title(titles[i])
    plt.savefig('msg_channels_visualization.png')
    plt.show()

# %% ../../nbs/01b_data.utils.ipynb 23
import matplotlib.pyplot as plt
from matplotlib import colors
import numpy as np

def plot_grid(msg_tensor):
    grid_indices = msg_tensor.argmax(dim=-1).cpu().numpy()

    color_list = ['#2C2C2C', '#5D4037', '#4CAF50', '#FF0000', '#0000FF']
    cmap = colors.ListedColormap(color_list)
    
    bounds = [0, 1, 2, 3, 4, 5]
    norm = colors.BoundaryNorm(bounds, cmap.N)

    plt.figure(figsize=(6, 6))
    img = plt.imshow(grid_indices, cmap=cmap, norm=norm)
    
    cbar = plt.colorbar(img, ticks=[0.5, 1.5, 2.5, 3.5, 4.5])
    cbar.ax.set_yticklabels(['Empty', 'Wall', 'Goal', 'Red', 'Blue'])
    
    plt.title("World Model: Decoded Message Grid")
    plt.grid(True, which='both', color='gray', linewidth=0.5, alpha=0.3)
    plt.show()



# %% ../../nbs/01b_data.utils.ipynb 30
def plot_grid(img_tensor, msg_tensor):
    grid_indices = msg_tensor.argmax(dim=-1).cpu().numpy()
    
    color_list = ['#2C2C2C', '#5D4037', '#4CAF50', '#FF0000', '#0000FF']
    cmap = colors.ListedColormap(color_list)
    
    bounds = [0, 1, 2, 3, 4, 5]
    norm = colors.BoundaryNorm(bounds, cmap.N)

    # plot image and grid side by side
    fig, axs = plt.subplots(1, 2, figsize=(12, 6))
    axs[0].imshow(img_tensor)
    axs[0].set_title("Original Image")
    axs[0].axis('off')
    img = axs[1].imshow(grid_indices, cmap=cmap, norm=norm)
    axs[1].set_title("Decoded Message Grid")
    axs[1].axis('off')
    
    cbar = fig.colorbar(img, ax=axs[1], ticks=[0.5, 1.5, 2.5, 3.5, 4.5])
    cbar.ax.set_yticklabels(['Empty', 'Wall', 'Goal', 'Red', 'Blue'])
    
    plt.show()

# %% ../../nbs/01b_data.utils.ipynb 33
import torch

from .loaders import MarlGridDataset
def init_data(cfg):
    train_ds = MarlGridDataset(
        data_path = cfg.data.data_dir,
        num_agents= len(cfg.env.agents),
        seq_len= cfg.data.seq_len,
        train= True,
        transform= base_tf,
        msg_tf= msg_tf
    )

    test_ds = MarlGridDataset(
        data_path = cfg.data.data_dir,
        num_agents= len(cfg.env.agents),
        seq_len= cfg.data.seq_len,
        train= False,
        transform= base_tf,
        msg_tf= msg_tf
    )

    train_loader = torch.utils.data.DataLoader(
        train_ds,
        batch_size=cfg.data.batch_size,
        shuffle=True,
    )

    val_loader = torch.utils.data.DataLoader(
        test_ds,
        batch_size=cfg.data.batch_size,
        shuffle=False,
    )

    return train_loader, val_loader


# %% ../../nbs/01b_data.utils.ipynb 44
import matplotlib.pyplot as plt
import numpy as np
import torchvision
import torch
import einops
def show_batch(dl, denormalize_tf, save_to="./batch.png"):
    dataiter = iter(dl)
    data = next(dataiter)
    images = data['agent_0']['obs']

    if images.ndim == 5:
        images = einops.rearrange(images, 'b s c h w -> (b s) c h w')
        print(images.shape)

    print(f"Max pixel value: {images.max().item()}")
    print(f"Mean pixel value: {images.mean().item()}")
    images = denormalize_tf(images) if denormalize_tf is not None else images
    print(f"After denormalization:")
    print("+"*20)
    print(f"Max pixel value: {images.max().item()}")
    print(f"Mean pixel value: {images.mean().item()}")
    images = torch.clamp(images, 0, 1)

    grid_img = torchvision.utils.make_grid(images, nrow=8) # nrow controls how many images per row
    np_grid = torch.einsum('chw->hwc', grid_img).numpy()


    plt.figure(figsize=(15, 10))
    plt.imshow(np_grid)
    plt.axis('off')
    plt.savefig(save_to, bbox_inches='tight')
    plt.savefig("pdf.pdf", bbox_inches='tight')
    plt.show()
